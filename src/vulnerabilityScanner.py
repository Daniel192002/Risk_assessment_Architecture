from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeCheckCommandTransform
from lxml import etree
from datetime import datetime
import time

# Importar los repositorios necesarios
from assetRepository import AssetRepository
from vulnerabilityRepository import VulnerabilityRepository

class VulnerabilityScanner:
    # El constructor ahora recibe las instancias de los repositorios
    def __init__(self, asset_repository: AssetRepository, vulnerability_repository: VulnerabilityRepository):
        self.asset_repo = asset_repository
        self.vuln_repo = vulnerability_repository
        self.connection = UnixSocketConnection(path='/run/gvmd/gvmd.sock')
        self.transform = EtreeCheckCommandTransform()
        # Puedes mover la autenticación aquí si prefieres que se haga una vez al inicio
        # self.gmp = Gmp(connection=self.connection, transform=self.transform)
        # self.gmp.authenticate('admin', '21edb9d3-ec32-4308-96e1-024d667de700')
        # print("[+] Autenticación exitosa con GVM.")
        # O dejarla por cada "with Gmp(...)" como lo tienes ahora, lo cual es más seguro
        # si la conexión puede caer y necesita ser restablecida.

    # def _get_gmp_connection(self):
    #     """Método auxiliar para obtener una conexión GMP autenticada."""
    #     gmp = Gmp(connection=self.connection, transform=self.transform)
    #     gmp.authenticate('admin', '21edb9d3-ec32-4308-96e1-024d667de700')
    #     return gmp

    def execute_scan(self):
        """
        Orquesta el escaneo de vulnerabilidades para todos los dispositivos
        detectados y guarda los resultados.
        """
        print("[+] VulnerabilityScanner: Iniciando escaneo de vulnerabilidades para todos los dispositivos...")
        
        # 1. Obtener la lista de dispositivos desde el AssetRepository
        # Asegúrate de que tu get_all_devices devuelva (mac, ipv4, ipv6)
        devices_to_scan = self.asset_repo.get_all_devices() 
        
        if not devices_to_scan:
            print("[!] VulnerabilityScanner: No se encontraron dispositivos registrados en la base de datos para escanear.")
            return

        print(f"[+] VulnerabilityScanner: Se han encontrado {len(devices_to_scan)} dispositivos para escanear.")

        with Gmp(connection=self.connection, transform=self.transform) as gmp:
            gmp.authenticate('admin', '21edb9d3-ec32-4308-96e1-024d667de700')
            
            for mac, ipv4, ipv6 in devices_to_scan:
                # Priorizamos IPv4 para el escaneo si está disponible
                ip_to_scan = ipv4 if ipv4 else ipv6
                
                if not ip_to_scan:
                    print(f"[-] VulnerabilityScanner: Dispositivo con MAC {mac} no tiene IPv4 ni IPv6. Saltando escaneo.")
                    continue
                
                print(f"\n[+] VulnerabilityScanner: Escaneando {ip_to_scan} (MAC: {mac})...")
                
                try:
                    # Llama al método scan_ip para realizar el escaneo GVM para una IP
                    cves_detected_for_ip = self.scan_ip(gmp, ip_to_scan)
                    
                    if cves_detected_for_ip:
                        print(f"[+] VulnerabilityScanner: Se detectaron {len(cves_detected_for_ip)} CVEs para {ip_to_scan}.")
                        # 2. Guardar las vulnerabilidades en el VulnerabilityRepository
                        for cve_id, severity, nvt_name, solution in cves_detected_for_ip:
                            # Asegurarse de no insertar duplicados
                            if not self.vuln_repo.cve_exists(ip_to_scan, cve_id):
                                self.vuln_repo.insert_vulnerability(mac, ip_to_scan, cve_id, severity, nvt_name, solution)
                                print(f"[+] VulnerabilityScanner: CVE {cve_id} para {ip_to_scan} guardado exitosamente.")
                            else:
                                print(f"[-] VulnerabilityScanner: CVE {cve_id} para {ip_to_scan} ya existe en la DB. Saltando.")
                    else:
                        print(f"[-] VulnerabilityScanner: No se encontraron CVEs para {ip_to_scan}.")
                except Exception as e:
                    print(f"[!] VulnerabilityScanner: Error durante el escaneo o guardado para {ip_to_scan}: {e}")
                
                # Pequeña pausa entre escaneos para no saturar GVM o la red (opcional)
                time.sleep(5)
        
        print("[+] VulnerabilityScanner: Proceso de escaneo de vulnerabilidades completado.")

    def scan_ip(self, gmp: Gmp, ip: str):
        """
        Realiza el escaneo de una única IP usando GVM y devuelve los CVEs detectados.
        Este método es una función de ayuda para execute_scan.
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        target_name = f"Scan-{ip}-{timestamp}"
        task_name = f"Task-{ip}-{timestamp}"
        print(f"[DEBUG] GVM: Nombre del objetivo: {target_name}")
        print(f"[DEBUG] GVM: Nombre de la tarea: {task_name}")
        
        try:
            # 1. Verificar o crear el port list si no se pasa por ID (esto debe ser más robusto)
            # Para este ejemplo, asumimos que 'Top 100 TCP and top 100 UDP' siempre existe.
            port_lists = gmp.get_port_lists(filter_string="name='Top 100 TCP and top 100 UDP'").xpath("port_list/@id")
            if not port_lists:
                raise ValueError("No se encontró el port list 'Top 100 TCP and top 100 UDP'")
            port_list_id = port_lists[0]
            
            # 2. Crear Target
            target_response = gmp.create_target(
                name = target_name,
                hosts = [ip],
                port_list_id = port_list_id
            )
            target_id = target_response.get("id")
            if not target_id:
                raise RuntimeError("No se pudo crear el target GVM.")
            print(f"[DEBUG] GVM: Objetivo creado: {target_name} (ID: {target_id})")

            # 3. Obtener el config ID
            config_id = None
            configs = gmp.get_scan_configs()
            for config in configs.xpath("scan_config"):
                name = config.find("name").text
                print(f"[DEBUG] GVM: Configuración encontrada: {name}")
                if "Full and fast" in name:
                    config_id = config.get("id")
                    break
            if not config_id:
                raise RuntimeError("No se encontró una configuración de escaneo válida ('Full and fast').")
            print(f"[DEBUG] GVM: Configuración de escaneo 'Full and fast'")
            
            # 4. Obtener scanner ID
            scanner_id = None
            scanners = gmp.get_scanners(filter_string="name='OpenVAS Default'")
            scanner_elem = scanners.xpath("scanner")[0] if scanners.xpath("scanner") else None
            if scanner_elem is not None:
                scanner_id = scanner_elem.get("id")
            if not scanner_id:
                raise RuntimeError("No se encontró un escáner válido ('OpenVAS Default').")
            print(f"[DEBUG] GVM: Escáner 'OpenVAS Default' (ID: {scanner_id})")

            # 5. Verificar si la tarea ya existe y su estado
            task_id = None
            existing_tasks = gmp.get_tasks(filter_string=f"name='{task_name}'")
            if existing_tasks.xpath("task"):
                task_elem = existing_tasks.xpath("task")[0]
                task_id = task_elem.get("id")
                status_elem = task_elem.find("status")
                task_status = status_elem.text if status_elem is not None else "Unknown"
                print(f"[DEBUG] GVM: Tarea existente: {task_name} (ID: {task_id}, Estado: {task_status})")
                
                if task_status not in ("Done", "Stopped", "Interrupted"):
                    print(f"[!] GVM: La tarea '{task_name}' ya está en ejecución (estado: {task_status}). Saltando escaneo para {ip}.")
                    return [] # Devolver lista vacía si ya está en curso
            
            if not task_id: # Si no existe o no se encontró una tarea válida
                response = gmp.create_task(task_name, config_id, target_id, scanner_id )
                task_id = response.get('id')
                print(f"[DEBUG] GVM: Tarea creada: {task_name} (ID: {task_id})")
            
            # 6. Iniciar la tarea 
            gmp.start_task(task_id)
            print(f"[✓] GVM: Escaneo iniciado para {ip} (task ID: {task_id})")
            print("[...] GVM: Esperando a que termine la tarea...")
            
            # 7. Esperar hasta que termine
            while True:
                task_info = gmp.get_task(task_id=task_id)
                task_elem = task_info.find("task")
                status = None
                
                if task_elem is not None:
                    status_elem = task_elem.find("status")
                    status = status_elem.text if status_elem is not None else "Unknown"
                else:
                    print("[ERROR] GVM: No se encontró el nodo <task> en la respuesta al verificar estado.")
                    break # Salir del bucle de espera
                
                print(f"[DEBUG] GVM: Estado actual de tarea {task_id}: {status}")
                if status in ("Done", "Stopped", "Interrupted"):
                    print(f"[✓] GVM: Escaneo finalizado para {ip} con estado: {status}.")
                    break
                time.sleep(15) # Esperar más tiempo entre comprobaciones, ya que los escaneos son largos

            # 8. Obtener resultados
            last_report_elem = task_elem.find(".//last_report/report") # Buscar dentro del elemento task
            if last_report_elem is None:
                print(f"[!] GVM: No se encontró el último reporte para la tarea {task_id}.")
                return []
            
            report_id = last_report_elem.get("id")
            print(f"[DEBUG] GVM: Reporte ID: {report_id}")
            
            report = gmp.get_report(report_id=report_id, details=True, ignore_pagination=True)
            
            # Opcional: guardar el reporte XML para depuración
            # with open(f"reporte_{ip.replace('.', '_')}.xml", "wb") as f:
            #     f.write(etree.tostring(report, pretty_print=True))
            # print(f"[✓] GVM: Reporte guardado como reporte_{ip.replace('.', '_')}.xml")
            
            return self.extract_cves(report)
            
        except Exception as e:
            print(f"[!] GVM: Error general en scan_ip para {ip}: {e}")
            return [] # Retornar lista vacía en caso de error

    def extract_cves(self, report):
        """
        Extrae información de CVEs relevantes del reporte XML de GVM.
        """
        cves_detected = []
        
        print(f"[+] GVM: Procesando resultados del escaneo...")
        for result in report.xpath(".//result"):
            severity = result.findtext("severity")
            nvt = result.find("nvt")
            
            if nvt is not None:
                nvt_name = nvt.findtext("name") or "Unknown NVT"
                solution = nvt.findtext("solution") or "No solution provided"
                refs = nvt.find("refs")
                
                # Filtrar solo resultados con severidad "High" o "Critical"
                # Puedes ajustar esta lógica de filtrado según tus necesidades
                if float(severity) >= 7.0: # CVSS Base Score para High (7.0-8.9) y Critical (9.0-10.0)
                    if refs is not None:
                        for ref in refs.findall("ref"):
                            if ref.get("type") == "cve":
                                cve_id = ref.get("id")
                                # Asegúrate de que la solución no sea muy larga para tu campo DB
                                solution_short = (solution[:500] + '...') if len(solution) > 500 else solution
                                cves_detected.append((cve_id, severity, nvt_name, solution_short))
                                print(f"[+] GVM CVE detectado: {cve_id} | Severity: {severity} | NVT: {nvt_name}")
                
